<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bad Apple!! Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'VT323', monospace; background-color: #1a1a1a; color: #e0e0e0; }
        canvas { background-color: #000; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; border: 2px solid #444; border-radius: 8px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.1); }
        .btn { background-color: #333; border: 2px solid #555; color: #fff; padding: 10px 20px; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 1px; }
        .btn:hover:not(:disabled) { background-color: #444; border-color: #777; transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .btn:disabled { cursor: not-allowed; opacity: 0.5; }
        .progress-bar-container { width: 100%; height: 10px; background-color: #333; border-radius: 5px; overflow: hidden; border: 1px solid #555; cursor: pointer; }
        .progress-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #a0a0a0, #ffffff); }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl text-center">
        <h1 class="text-4xl md:text-5xl mb-4 text-white">Bad Apple!!</h1>
        <p class="text-gray-400 mb-6">Press Play to start the animation.</p>
        
        <canvas id="badAppleCanvas" class="w-full aspect-video mx-auto"></canvas>

        <audio id="badAppleAudio" src="badapple.mp3" preload="metadata"></audio>

        <div class="mt-6 flex flex-col sm:flex-row items-center justify-center gap-4 w-full">
            <button id="playPauseBtn" class="btn w-full sm:w-auto">Play</button>
            <div id="progressContainer" class="progress-bar-container w-full sm:w-1/2">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <div id="frameCounter" class="text-lg w-full sm:w-auto text-center sm:text-left">Frame: 0 / 0</div>
        </div>
    </div>

    <script src="frame_data.js"></script>
    
    <script>
        const CANVAS_WIDTH = 512;
        const CANVAS_HEIGHT = 384;
        const FPS = 30;

        const canvas = document.getElementById('badAppleCanvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('badAppleAudio');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const frameCounter = document.getElementById('frameCounter');

        let animationFrameId;
        // This off-screen canvas will hold the state of the previous frame
        const backBuffer = document.createElement('canvas');
        backBuffer.width = CANVAS_WIDTH;
        backBuffer.height = CANVAS_HEIGHT;
        const backCtx = backBuffer.getContext('2d');

        function setup() {
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            audio.addEventListener('error', handleAudioError);
            audio.addEventListener('timeupdate', updateUI);
            audio.addEventListener('ended', handleAudioEnded);
            audio.addEventListener('loadeddata', updateUI);
            
            if (typeof compressedFrames === 'undefined' || compressedFrames.length === 0) {
                drawNoDataMessage("NO FRAME DATA", "Is frame_data.js present?");
                playPauseBtn.disabled = true;
            } else {
                drawFrame(0); // Draw the initial keyframe
                updateUI();
            }
        }
        
        function handleAudioError() {
            playPauseBtn.disabled = true;
            playPauseBtn.textContent = 'Audio Error';
            drawNoDataMessage("AUDIO ERROR", "Could not load badapple.mp3");
            console.error("Failed to load audio file. Make sure 'badapple.mp3' is in the repository.");
        }
        
        function handleAudioEnded() {
            playPauseBtn.textContent = 'Play';
            cancelAnimationFrame(animationFrameId);
        }

        function animationLoop() {
            if (typeof compressedFrames === 'undefined') return;
            const targetFrame = Math.floor(audio.currentTime * FPS);
            
            if (targetFrame < compressedFrames.length) {
                drawFrame(targetFrame);
            }
            
            if (!audio.paused) {
                 animationFrameId = requestAnimationFrame(animationLoop);
            }
        }

        function drawNoDataMessage(line1, line2) {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.font = '14px VT323';
            ctx.fillText(line1, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 10);
            ctx.fillText(line2, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 10);
        }

        function drawFrame(frameIndex) {
            const frameInfo = compressedFrames[frameIndex];
            if (!frameInfo) return;

            if (frameInfo.type === 'key') {
                // Draw a full keyframe using RLE
                drawRleFrame(frameInfo.data, backCtx);
            } else if (frameInfo.type === 'delta') {
                // Apply changes to the previous frame's data
                drawDeltaFrame(frameInfo.data, backCtx);
            }
            
            // Copy the updated back buffer to the visible canvas
            ctx.drawImage(backBuffer, 0, 0);
        }

        function drawRleFrame(rleData, context) {
            if (!rleData) return;
            let x = 0;
            let y = 0;
            let colorIndex = 0;
            context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            for (const runLength of rleData) {
                if (runLength === 0) {
                     colorIndex = 1 - colorIndex;
                     continue;
                }
                context.fillStyle = colorIndex === 0 ? 'black' : 'white';
                let remainingInRun = runLength;
                while (remainingInRun > 0) {
                    const printableLength = Math.min(remainingInRun, CANVAS_WIDTH - x);
                    if (printableLength > 0) {
                         context.fillRect(x, y, printableLength, 1);
                    }
                    x += printableLength;
                    remainingInRun -= printableLength;
                    if (x >= CANVAS_WIDTH) {
                        x = 0;
                        y++;
                    }
                }
                colorIndex = 1 - colorIndex;
            }
        }

        function drawDeltaFrame(deltaData, context) {
            if (!deltaData) return;
            // The magic: we just flip the color of the changed pixels
            for (const [y, x] of deltaData) {
                const pixel = context.getImageData(x, y, 1, 1).data;
                // If it was black (or transparent), make it white. Otherwise, make it black.
                context.fillStyle = (pixel[0] === 0) ? 'white' : 'black';
                context.fillRect(x, y, 1, 1);
            }
        }
        
        function togglePlayPause() {
            if (audio.paused) {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        playPauseBtn.textContent = 'Pause';
                        animationFrameId = requestAnimationFrame(animationLoop);
                    }).catch(handleAudioError);
                }
            } else {
                audio.pause();
                playPauseBtn.textContent = 'Play';
                cancelAnimationFrame(animationFrameId);
            }
        }

        function handleSeek(event) {
            if (!audio.duration) return;
            const bounds = progressContainer.getBoundingClientRect();
            const clickPosition = event.clientX - bounds.left;
            const percentage = Math.max(0, Math.min(1, clickPosition / bounds.width));

            audio.currentTime = percentage * audio.duration;
            // To seek, we must rebuild the frame from the start
            rebuildFrameTo(Math.floor(audio.currentTime * FPS));
        }

        function rebuildFrameTo(targetFrameIndex) {
            // Find the last keyframe before our target
            let lastKeyFrameIndex = 0;
            for (let i = targetFrameIndex; i >= 0; i--) {
                if (compressedFrames[i].type === 'key') {
                    lastKeyFrameIndex = i;
                    break;
                }
            }
            // Draw that keyframe first
            drawFrame(lastKeyFrameIndex);

            // Now apply all delta changes from that keyframe up to our target
            for (let i = lastKeyFrameIndex + 1; i <= targetFrameIndex; i++) {
                drawFrame(i);
            }
        }
        
        function updateUI() {
            if (typeof compressedFrames === 'undefined') return;
            const frameCount = compressedFrames.length > 0 ? compressedFrames.length : 0;
            const currentDisplayFrame = audio.currentTime ? Math.floor(audio.currentTime * FPS) : 0;
            frameCounter.textContent = `Frame: ${currentDisplayFrame} / ${frameCount}`;

            if (audio.duration) {
                const progressPercentage = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${progressPercentage}%`;
            }
        }

        playPauseBtn.addEventListener('click', togglePlayPause);
        progressContainer.addEventListener('click', handleSeek);
        
        window.addEventListener('load', setup);
    </script>

</body>
</html>
