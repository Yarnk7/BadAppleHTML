<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bad Apple!! Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'VT323', monospace; background-color: #1a1a1a; color: #e0e0e0; }
        canvas { background-color: #000; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; border: 2px solid #444; border-radius: 8px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.1); }
        .btn { background-color: #333; border: 2px solid #555; color: #fff; padding: 10px 20px; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 1px; }
        .btn:hover:not(:disabled) { background-color: #444; border-color: #777; transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .btn:disabled { cursor: not-allowed; opacity: 0.5; }
        .progress-bar-container { width: 100%; height: 10px; background-color: #333; border-radius: 5px; overflow: hidden; border: 1px solid #555; cursor: pointer; }
        .progress-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #a0a0a0, #ffffff); }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl text-center">
        <h1 class="text-4xl md:text-5xl mb-4 text-white">Bad Apple!!</h1>
        <p class="text-gray-400 mb-6">Press Play to start the animation.</p>
        
        <canvas id="badAppleCanvas" class="w-full aspect-video mx-auto"></canvas>

        <audio id="badAppleAudio" src="badapple.mp3" preload="metadata"></audio>

        <div class="mt-6 flex flex-col sm:flex-row items-center justify-center gap-4 w-full">
            <button id="playPauseBtn" class="btn w-full sm:w-auto">Play</button>
            <div id="progressContainer" class="progress-bar-container w-full sm:w-1/2">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <div id="frameCounter" class="text-lg w-full sm:w-auto text-center sm:text-left">Frame: 0 / 0</div>
        </div>
    </div>

    <script src="frame_data.js"></script>
    
    <script>
        const CANVAS_WIDTH = 512;
        const CANVAS_HEIGHT = 384;
        const FPS = 30;
        const TOTAL_PIXELS = CANVAS_WIDTH * CANVAS_HEIGHT;

        const canvas = document.getElementById('badAppleCanvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('badAppleAudio');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const frameCounter = document.getElementById('frameCounter');

        let animationFrameId;
        let currentFrameIndex = -1;
        
        let pixelState = new Uint8ClampedArray(TOTAL_PIXELS * 4);

        function setup() {
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            audio.addEventListener('error', handleAudioError);
            audio.addEventListener('timeupdate', updateUI);
            audio.addEventListener('ended', handleAudioEnded);
            audio.addEventListener('loadeddata', updateUI);
            if (typeof compressedFrames === 'undefined' || compressedFrames.length === 0) {
                drawNoDataMessage("NO FRAME DATA", "Is frame_data.js present?");
                playPauseBtn.disabled = true;
            } else {
                rebuildPixelStateTo(0);
                drawPixelState();
                updateUI();
            }
        }
        
        function handleAudioError() {
            playPauseBtn.disabled = true;
            playPauseBtn.textContent = 'Audio Error';
            drawNoDataMessage("AUDIO ERROR", "Could not load badapple.mp3");
        }
        
        function handleAudioEnded() {
            playPauseBtn.textContent = 'Play';
            cancelAnimationFrame(animationFrameId);
        }

        function animationLoop() {
            if (audio.paused || typeof compressedFrames === 'undefined') {
                cancelAnimationFrame(animationFrameId);
                return;
            }
            
            const targetFrame = Math.floor(audio.currentTime * FPS);

            if (targetFrame > currentFrameIndex && targetFrame < compressedFrames.length) {
                // This logic is much more robust for catching up on skipped frames
                while (currentFrameIndex < targetFrame) {
                    currentFrameIndex++;
                    const frameInfo = compressedFrames[currentFrameIndex];
                    if (frameInfo.type === 'd') {
                        applyDeltaToPixelState(frameInfo.data);
                    } else if (frameInfo.type === 'k') {
                        buildRleFrame(frameInfo.data);
                    }
                }
                drawPixelState();
            }
            
            animationFrameId = requestAnimationFrame(animationLoop);
        }
        
        function drawPixelState() {
            const imageData = new ImageData(pixelState, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.putImageData(imageData, 0, 0);
        }

        function drawNoDataMessage(line1, line2) {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.font = '14px VT323';
            ctx.fillText(line1, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 10);
            ctx.fillText(line2, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 10);
        }

        function buildRleFrame(rleData) {
            let i = 0;
            let colorIndex = 0;
            for (const runLength of rleData) {
                const colorVal = colorIndex === 0 ? 0 : 255;
                for (let j = 0; j < runLength; j++) {
                    pixelState[i] = colorVal;
                    pixelState[i + 1] = colorVal;
                    pixelState[i + 2] = colorVal;
                    pixelState[i + 3] = 255;
                    i += 4;
                }
                colorIndex = 1 - colorIndex;
            }
        }
        
        function applyDeltaToPixelState(b64Data) {
            try {
                const decodedString = atob(b64Data);
                const byteData = new Uint8Array(decodedString.length);
                for (let i = 0; i < decodedString.length; i++) {
                    byteData[i] = decodedString.charCodeAt(i);
                }
                for (let i = 0; i < byteData.length; i += 3) {
                    const index = (byteData[i] << 16) | (byteData[i+1] << 8) | byteData[i+2];
                    const pixelIndex = index * 4;
                    const colorVal = pixelState[pixelIndex] === 0 ? 255 : 0;
                    pixelState[pixelIndex] = colorVal;
                    pixelState[pixelIndex + 1] = colorVal;
                    pixelState[pixelIndex + 2] = colorVal;
                }
            } catch (e) {
                console.error("Failed to decode or apply delta frame:", e);
            }
        }
        
        function togglePlayPause() {
            if (audio.paused) {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        playPauseBtn.textContent = 'Pause';
                        animationFrameId = requestAnimationFrame(animationLoop);
                    }).catch(handleAudioError);
                }
            } else {
                audio.pause();
                playPauseBtn.textContent = 'Play';
                cancelAnimationFrame(animationFrameId);
            }
        }

        function handleSeek(event) {
            if (!audio.duration) return;
            const bounds = progressContainer.getBoundingClientRect();
            const clickPosition = event.clientX - bounds.left;
            const percentage = Math.max(0, Math.min(1, clickPosition / bounds.width));
            const newTime = percentage * audio.duration;
            audio.currentTime = newTime;

            // After setting the time, immediately rebuild and draw to prevent flicker
            const targetFrame = Math.floor(newTime * FPS);
            rebuildPixelStateTo(targetFrame);
            drawPixelState();
            currentFrameIndex = targetFrame;
        }

        function rebuildPixelStateTo(targetFrameIndex) {
            if (targetFrameIndex < 0 || targetFrameIndex >= compressedFrames.length) return;
            
            let lastKeyFrameIndex = 0;
            for (let i = targetFrameIndex; i >= 0; i--) {
                if (compressedFrames[i] && compressedFrames[i].type === 'k') {
                    lastKeyFrameIndex = i;
                    break;
                }
            }
            
            buildRleFrame(compressedFrames[lastKeyFrameIndex].data);
            
            for (let i = lastKeyFrameIndex + 1; i <= targetFrameIndex; i++) {
                 const frameInfo = compressedFrames[i];
                 if (frameInfo.type === 'd') {
                    applyDeltaToPixelState(frameInfo.data);
                } else if (frameInfo.type === 'k') {
                    buildRleFrame(frameInfo.data);
                }
            }
        }
        
        function updateUI() {
            if (typeof compressedFrames === 'undefined') return;
            const frameCount = compressedFrames.length > 0 ? compressedFrames.length : 0;
            const currentDisplayFrame = audio.currentTime ? Math.floor(audio.currentTime * FPS) : 0;
            frameCounter.textContent = `Frame: ${currentDisplayFrame} / ${frameCount}`;
            if (audio.duration) {
                progressBar.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
            }
        }

        playPauseBtn.addEventListener('click', togglePlayPause);
        progressContainer.addEventListener('click', handleSeek);
        
        window.addEventListener('load', setup);
    </script>

</body>
</html>
