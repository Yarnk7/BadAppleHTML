<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bad Apple!! Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'VT323', monospace; background-color: #1a1a1a; color: #e0e0e0; }
        canvas { background-color: #000; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; border: 2px solid #444; border-radius: 8px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.1); }
        .btn { background-color: #333; border: 2px solid #555; color: #fff; padding: 10px 20px; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 1px; }
        .btn:hover:not(:disabled) { background-color: #444; border-color: #777; transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .btn:disabled { cursor: not-allowed; opacity: 0.5; }
        .progress-bar-container { width: 100%; height: 10px; background-color: #333; border-radius: 5px; overflow: hidden; border: 1px solid #555; cursor: pointer; }
        .progress-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #a0a0a0, #ffffff); }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl text-center">
        <h1 class="text-4xl md:text-5xl mb-4 text-white">Bad Apple!!</h1>
        <p class="text-gray-400 mb-6">Press Play to start the animation.</p>
        
        <canvas id="badAppleCanvas" class="w-full aspect-video mx-auto"></canvas>

        <audio id="badAppleAudio" src="badapple.mp3" preload="metadata"></audio>

        <div class="mt-6 flex flex-col sm:flex-row items-center justify-center gap-4 w-full">
            <button id="playPauseBtn" class="btn w-full sm:w-auto">Play</button>
            <div id="progressContainer" class="progress-bar-container w-full sm:w-1/2">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <div id="frameCounter" class="text-lg w-full sm:w-auto text-center sm:text-left">Frame: 0 / 0</div>
        </div>
    </div>

    <script src="frame_data.js"></script>
    
    <script>
        const CANVAS_WIDTH = 512;
        const CANVAS_HEIGHT = 384;
        const FPS = 30;

        const canvas = document.getElementById('badAppleCanvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('badAppleAudio');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const frameCounter = document.getElementById('frameCounter');

        let animationFrameId;
        let currentFrameIndex = -1;
        
        const backBuffer = document.createElement('canvas');
        backBuffer.width = CANVAS_WIDTH;
        backBuffer.height = CANVAS_HEIGHT;
        const backCtx = backBuffer.getContext('2d');

        function setup() {
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            audio.addEventListener('error', handleAudioError);
            audio.addEventListener('timeupdate', updateUI);
            audio.addEventListener('ended', handleAudioEnded);
            audio.addEventListener('loadeddata', updateUI);
            if (typeof compressedFrames === 'undefined' || compressedFrames.length === 0) {
                drawNoDataMessage("NO FRAME DATA", "Is frame_data.js present?");
                playPauseBtn.disabled = true;
            } else {
                drawFrame(0);
                updateUI();
            }
        }
        
        function handleAudioError() {
            playPauseBtn.disabled = true;
            playPauseBtn.textContent = 'Audio Error';
            drawNoDataMessage("AUDIO ERROR", "Could not load badapple.mp3");
        }
        
        function handleAudioEnded() {
            playPauseBtn.textContent = 'Play';
            cancelAnimationFrame(animationFrameId);
        }

        function animationLoop() {
            if (typeof compressedFrames === 'undefined') return;
            const targetFrame = Math.floor(audio.currentTime * FPS);
            if (targetFrame !== currentFrameIndex && targetFrame < compressedFrames.length) {
                if(targetFrame === currentFrameIndex + 1) {
                    drawFrame(targetFrame);
                } else {
                    rebuildFrameTo(targetFrame);
                }
                currentFrameIndex = targetFrame;
            }
            if (!audio.paused) {
                 animationFrameId = requestAnimationFrame(animationLoop);
            }
        }

        function drawNoDataMessage(line1, line2) {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.font = '14px VT323';
            ctx.fillText(line1, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 10);
            ctx.fillText(line2, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 10);
        }

        function drawFrame(frameIndex) {
            const frameInfo = compressedFrames[frameIndex];
            if (!frameInfo) return;
            if (frameInfo.type === 'k') {
                drawRleFrame(frameInfo.data, backCtx);
            } else if (frameInfo.type === 'd') {
                drawDeltaFrameOptimized(frameInfo.data, backCtx);
            }
            ctx.drawImage(backBuffer, 0, 0);
        }

        function drawRleFrame(rleData, context) {
            let x = 0, y = 0, colorIndex = 0;
            context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            for (const runLength of rleData) {
                if (runLength === 0) { colorIndex = 1 - colorIndex; continue; }
                context.fillStyle = colorIndex === 0 ? 'black' : 'white';
                let remainingInRun = runLength;
                while (remainingInRun > 0) {
                    const printableLength = Math.min(remainingInRun, CANVAS_WIDTH - x);
                    if (printableLength > 0) context.fillRect(x, y, printableLength, 1);
                    x += printableLength;
                    remainingInRun -= printableLength;
                    if (x >= CANVAS_WIDTH) { x = 0; y++; }
                }
                colorIndex = 1 - colorIndex;
            }
        }

        // --- OPTIMIZED DELTA DRAWING FUNCTION ---
        function drawDeltaFrameOptimized(b64Data, context) {
            try {
                // Get all pixel data from the canvas at once
                const imageData = context.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                const pixels = imageData.data;

                // Decode the Base64 string into a byte array
                const decodedString = atob(b64Data);
                const byteData = new Uint8Array(decodedString.length);
                for (let i = 0; i < decodedString.length; i++) {
                    byteData[i] = decodedString.charCodeAt(i);
                }

                // Loop through the byte array to get the changed pixel indices
                for (let i = 0; i < byteData.length; i += 3) {
                    const index = (byteData[i] << 16) | (byteData[i+1] << 8) | byteData[i+2];
                    const pixelIndex = index * 4; // Each pixel is 4 bytes (R,G,B,A)
                    
                    // Flip the color in the pixel data array
                    if (pixels[pixelIndex] === 0) { // If it's black...
                        pixels[pixelIndex] = 255;     // R
                        pixels[pixelIndex + 1] = 255; // G
                        pixels[pixelIndex + 2] = 255; // B
                    } else { // If it's white...
                        pixels[pixelIndex] = 0;       // R
                        pixels[pixelIndex + 1] = 0;   // G
                        pixels[pixelIndex + 2] = 0;   // B
                    }
                    // Alpha (pixelIndex + 3) is always 255 (opaque)
                }

                // Put the modified pixel data back onto the canvas at once
                context.putImageData(imageData, 0, 0);

            } catch (e) {
                console.error("Failed to decode or draw delta frame:", e);
            }
        }
        
        function togglePlayPause() {
            if (audio.paused) {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        playPauseBtn.textContent = 'Pause';
                        animationFrameId = requestAnimationFrame(animationLoop);
                    }).catch(handleAudioError);
                }
            } else {
                audio.pause();
                playPauseBtn.textContent = 'Play';
                cancelAnimationFrame(animationFrameId);
            }
        }

        function handleSeek(event) {
            if (!audio.duration) return;
            const bounds = progressContainer.getBoundingClientRect();
            const clickPosition = event.clientX - bounds.left;
            const percentage = Math.max(0, Math.min(1, clickPosition / bounds.width));
            const newTime = percentage * audio.duration;
            audio.currentTime = newTime;
            const targetFrame = Math.floor(newTime * FPS);
            rebuildFrameTo(targetFrame);
            currentFrameIndex = targetFrame;
        }

        function rebuildFrameTo(targetFrameIndex) {
            if (targetFrameIndex < 0) return;
            let lastKeyFrameIndex = 0;
            for (let i = targetFrameIndex; i >= 0; i--) {
                if (compressedFrames[i].type === 'k') {
                    lastKeyFrameIndex = i;
                    break;
                }
            }
            drawFrame(lastKeyFrameIndex);
            for (let i = lastKeyFrameIndex + 1; i <= targetFrameIndex; i++) {
                drawFrame(i);
            }
        }
        
        function updateUI() {
            if (typeof compressedFrames === 'undefined') return;
            const frameCount = compressedFrames.length > 0 ? compressedFrames.length : 0;
            const currentDisplayFrame = audio.currentTime ? Math.floor(audio.currentTime * FPS) : 0;
            frameCounter.textContent = `Frame: ${currentDisplayFrame} / ${frameCount}`;
            if (audio.duration) {
                progressBar.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
            }
        }

        playPauseBtn.addEventListener('click', togglePlayPause);
        progressContainer.addEventListener('click', handleSeek);
        
        window.addEventListener('load', setup);
    </script>

</body>
</html>
